# Реализация метода рекурсивного спуска для синтаксического анализа

## Постановка задачи:

**Цель:** разработать для грамматики алгоритм синтаксического анализа на основе метода рекурсивного спуска.

**Задачи:**
- В соответствии с вариантом для заданной грамматики необходимо разработать и реализовать алгоритм синтаксического анализа на основе метода рекурсивного спуска;
- В окне результатов отражается последовательность вызова процедур обработки символов грамматики в соответствии с деревом рекурсивного спуска;
- При наличии ошибки разбор продолжается с вышестоящего по отношению к ошибочному узлу куста;
- Реализовать для своего варианта задания в данной лабораторной работе алгоритм лексического анализа (лексемная декомпозиция и поиск лексических ошибок).

## Персональный вариант задания:

2 вариант: 

Для грамматики G[<условный оператор>] разработать и реализовать алгоритм анализа на основе метода рекурсивного спуска. G[<условный оператор>]:

```bnf
1. <условный оператор> ::= IF <условие> THEN <оператор>
2. <условие> ::= <выражение> <операция отношения>
<выражение>
3. <выражение> ::= <терм> {+ <терм>}
4. <терм> ::= <множитель> {* <множитель>}
5. <множитель> ::= < идентификатор > | (<выражение>)
6. <идентификатор> ::= <буква> {<буква> | <число>}
7. <оператор> ::= <выражение> | <условный оператор>
<операция отношения> ::= ”==” | ”<” | ”<=” | ”>” | ”>=” | ”!=”
<буква> ::= a | b | c | … | z | A | B | … | Z
<число> ::= <цифра> {<цифра>}
<цифра> 0 | 1 |...| 8 | 9
```

## Язык грамматики:

```bnf
L(G[<условный оператор>]) = { 
    w | w = "IF" <условие> "THEN" <оператор>,
    где:
    
    <условие> ::= <выражение> <операция_отношения> <выражение>
    
    <оператор> ::= <выражение> 
                 | "IF" <условие> "THEN" <оператор>  // рекурсивный случай
                 
    <выражение> ::= <терм> 
                  | <терм> "+" <выражение>
                  
    <терм> ::= <множитель> 
             | <множитель> "*" <терм>
             
    <множитель> ::= IDENTIFIER
                  | "(" <выражение> ")"
                  
    <операция_отношения> ::= "==" | "<" | "<=" | ">" | ">=" | "!="
    
    IDENTIFIER ::= [a-zA-Z][a-zA-Z0-9]*
}
```

## Классификация грамматики: 

Контекстно-свободная (все правила имеют форму `A → α`, где `A` — нетерминал). Содержит левую рекурсию в правилах для выражений.

## Схема вызова функций: 

```bnf
Parser.Parse()
├── ParseConditionalStatement()  
│   ├── ParseCondition()        
│   │   ├── ParseExpression()    
│   │   │   ├── ParseTerm()
│   │   │   │   └── ParseFactor()
│   │   │   │       ├── (рекурсия в ParseExpression при скобках)
│   │   │   │       └── ParseIdentifier()
│   │   │   └── (рекурсия при +)
│   │   ├── ParseRelationOp()     
│   │   └── ParseExpression()    
│   └── ParseStatement()        
│       ├── ParseExpression()    
│       └── ParseConditionalStatement()  
│
└── (проверка конца ввода)
```

## Диаграмма сканеа: 
![Диаграмма сканера](/scaner.png)

## Тестовые примеры: 
![Корректный ввод](/test1.png)

![Ошибочный ввод](/test2.png)

![Ошибочный ввод](/test3.png)

![Ошибочный ввод](/test4.png)

![Ошибочный ввод](/test5.png)
